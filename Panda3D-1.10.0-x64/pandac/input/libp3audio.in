1509981758
3 2
10 libp3audio 4 M_1l 12 panda3d.core 
94
95 16 FilterProperties 0 4 189 34 FilterProperties::FilterProperties 0 2 1 2 0
120
FilterProperties::FilterProperties(void);
inline FilterProperties::FilterProperties(FilterProperties const &) = default;

96 5 clear 0 4 189 23 FilterProperties::clear 0 1 3 42
/**
 * Removes all DSP postprocessing.
 */
42
inline void FilterProperties::clear(void);

97 11 add_lowpass 0 4 189 29 FilterProperties::add_lowpass 0 1 4 60
/**
 * Add a lowpass filter to the end of the DSP chain.
 */
92
inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q);

98 12 add_highpass 0 4 189 30 FilterProperties::add_highpass 0 1 5 61
/**
 * Add a highpass filter to the end of the DSP chain.
 */
93
inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q);

99 8 add_echo 0 4 189 26 FilterProperties::add_echo 0 1 6 57
/**
 * Add a echo filter to the end of the DSP chain.
 */
122
inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio);

100 10 add_flange 0 4 189 28 FilterProperties::add_flange 0 1 7 59
/**
 * Add a flange filter to the end of the DSP chain.
 */
118
inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate);

101 11 add_distort 0 4 189 29 FilterProperties::add_distort 0 1 8 60
/**
 * Add a distort filter to the end of the DSP chain.
 */
61
inline void FilterProperties::add_distort(PN_stdfloat level);

102 13 add_normalize 0 4 189 31 FilterProperties::add_normalize 0 1 9 62
/**
 * Add a normalize filter to the end of the DSP chain.
 */
109
inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp);

103 11 add_parameq 0 4 189 29 FilterProperties::add_parameq 0 1 10 60
/**
 * Add a parameq filter to the end of the DSP chain.
 */
108
inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain);

104 14 add_pitchshift 0 4 189 32 FilterProperties::add_pitchshift 0 1 11 63
/**
 * Add a pitchshift filter to the end of the DSP chain.
 */
106
inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap);

105 10 add_chorus 0 4 189 28 FilterProperties::add_chorus 0 1 12 59
/**
 * Add a chorus filter to the end of the DSP chain.
 */
171
inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth);

106 13 add_sfxreverb 0 4 189 31 FilterProperties::add_sfxreverb 0 1 13 59
/**
 * Add a reverb filter to the end of the DSP chain.
 */
491
inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250);

107 12 add_compress 0 4 189 30 FilterProperties::add_compress 0 1 14 61
/**
 * Add a compress filter to the end of the DSP chain.
 */
131
inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup);

108 14 get_class_type 0 4 189 32 FilterProperties::get_class_type 0 1 15 0
57
static TypeHandle FilterProperties::get_class_type(void);

109 4 play 0 6 191 16 AudioSound::play 0 1 16 350
// For best compatibility, set the loop_count, volume, and balance, prior to
// calling play().  You may set them while they're playing, but it's
// implementation specific whether you get the results.  - Calling play() a
// second time on the same sound before it is finished will start the sound
// again (creating a skipping or stuttering effect).
40
virtual void AudioSound::play(void) = 0;

110 4 stop 0 6 191 16 AudioSound::stop 0 1 17 0
40
virtual void AudioSound::stop(void) = 0;

111 8 set_loop 0 6 191 20 AudioSound::set_loop 0 1 18 65
// loop: false = play once; true = play forever.  inits to false.
56
virtual void AudioSound::set_loop(bool loop = true) = 0;

112 8 get_loop 0 6 191 20 AudioSound::get_loop 0 1 19 0
50
virtual bool AudioSound::get_loop(void) const = 0;

113 14 set_loop_count 0 6 191 26 AudioSound::set_loop_count 0 1 20 73
// loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.
78
virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0;

114 14 get_loop_count 0 6 191 26 AudioSound::get_loop_count 0 1 21 0
69
virtual unsigned long int AudioSound::get_loop_count(void) const = 0;

115 8 set_time 0 6 191 20 AudioSound::set_time 0 1 22 669
/*
 * Control time position within the sound.  This is similar (in concept) to
 * the seek position within a file.  time in seconds: 0 = beginning; length()
 * = end.  inits to 0.0. - The current time position will not change while the
 * sound is playing; you must call play() again to effect the change.  To play
 * the same sound from a time offset a second time, explicitly set the time
 * position again.  When looping, the second and later loops will start from
 * the beginning of the sound.  - If a sound is playing, calling get_time()
 * repeatedly will return different results over time.  e.g.: PN_stdfloat
 * percent_complete = s.get_time()  s.length();
 */
68
virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0;

116 8 get_time 0 6 191 20 AudioSound::get_time 0 1 23 0
57
virtual PN_stdfloat AudioSound::get_time(void) const = 0;

117 10 set_volume 0 6 191 22 AudioSound::set_volume 0 1 24 45
// 0 = minimum; 1.0 = maximum.  inits to 1.0.
66
virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0;

118 10 get_volume 0 6 191 22 AudioSound::get_volume 0 1 25 0
59
virtual PN_stdfloat AudioSound::get_volume(void) const = 0;

119 11 set_balance 0 6 191 23 AudioSound::set_balance 0 1 26 68
// -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.
74
virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0;

120 11 get_balance 0 6 191 23 AudioSound::get_balance 0 1 27 0
60
virtual PN_stdfloat AudioSound::get_balance(void) const = 0;

121 13 set_play_rate 0 6 191 25 AudioSound::set_play_rate 0 1 28 62
// play_rate is any positive PN_stdfloat value.  inits to 1.0.
72
virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0;

122 13 get_play_rate 0 6 191 25 AudioSound::get_play_rate 0 1 29 0
62
virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0;

123 10 set_active 0 6 191 22 AudioSound::set_active 0 1 30 28
// inits to manager's state.
58
virtual void AudioSound::set_active(bool flag = true) = 0;

124 10 get_active 0 6 191 22 AudioSound::get_active 0 1 31 0
52
virtual bool AudioSound::get_active(void) const = 0;

125 18 set_finished_event 0 6 191 30 AudioSound::set_finished_event 0 1 32 126
// Set (or clear) the event that will be thrown when the sound finishes
// playing.  To clear the event, pass an empty string.
74
virtual void AudioSound::set_finished_event(std::string const &event) = 0;

126 18 get_finished_event 0 6 191 30 AudioSound::get_finished_event 0 1 33 0
74
virtual std::string const &AudioSound::get_finished_event(void) const = 0;

127 8 get_name 0 6 191 20 AudioSound::get_name 0 1 34 47
// There is no set_name(), this is intentional.
64
virtual std::string const &AudioSound::get_name(void) const = 0;

128 6 length 0 6 191 18 AudioSound::length 0 1 35 35
// return: playing time in seconds.
55
virtual PN_stdfloat AudioSound::length(void) const = 0;

129 17 set_3d_attributes 0 6 191 29 AudioSound::set_3d_attributes 0 1 36 179
// Controls the position of this sound's emitter.  px, py and pz are the
// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
// PER SECOND (default: meters).
139
virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz);

130 17 get_3d_attributes 0 6 191 29 AudioSound::get_3d_attributes 0 0 0
145
virtual void AudioSound::get_3d_attributes(PN_stdfloat *px, PN_stdfloat *py, PN_stdfloat *pz, PN_stdfloat *vx, PN_stdfloat *vy, PN_stdfloat *vz);

131 19 set_3d_min_distance 0 6 191 31 AudioSound::set_3d_min_distance 0 1 37 168
// Controls the distance (in units) that this sound begins to fall off.
// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
// FartherSlower, >1.0
63
virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist);

132 19 get_3d_min_distance 0 6 191 31 AudioSound::get_3d_min_distance 0 1 38 0
64
virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const;

133 19 set_3d_max_distance 0 6 191 31 AudioSound::set_3d_max_distance 0 1 39 222
// Controls the maximum distance (in units) that this sound stops falling
// off.  The sound does not stop at that point, it just doesn't get any
// quieter.  You should rarely need to adjust this.  Default is 1000000000.0
63
virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist);

134 19 get_3d_max_distance 0 6 191 31 AudioSound::get_3d_max_distance 0 1 40 0
64
virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const;

135 15 get_speaker_mix 0 6 191 27 AudioSound::get_speaker_mix 0 1 41 312
// *_speaker_mix and *_speaker_level(s) serve the same purpose.
// *_speaker_mix is for use with FMOD. *_speaker_level(s) is for use with
// Miles.  Both interfaces exist because of a significant difference in the
// two APIs.  Hopefully the difference can be reconciled into a single
// interface at some point.
61
virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker);

136 15 set_speaker_mix 0 6 191 27 AudioSound::set_speaker_mix 0 1 42 0
215
virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright);

137 17 get_speaker_level 0 6 191 29 AudioSound::get_speaker_level 0 1 43 0
61
virtual PN_stdfloat AudioSound::get_speaker_level(int index);

138 18 set_speaker_levels 0 6 191 30 AudioSound::set_speaker_levels 0 1 44 0
280
virtual void AudioSound::set_speaker_levels(PN_stdfloat level1, PN_stdfloat level2 = -1.0, PN_stdfloat level3 = -1.0, PN_stdfloat level4 = -1.0, PN_stdfloat level5 = -1.0, PN_stdfloat level6 = -1.0, PN_stdfloat level7 = -1.0, PN_stdfloat level8 = -1.0, PN_stdfloat level9 = -1.0);

139 12 get_priority 0 6 191 24 AudioSound::get_priority 0 1 45 0
43
virtual int AudioSound::get_priority(void);

140 12 set_priority 0 6 191 24 AudioSound::set_priority 0 1 46 0
52
virtual void AudioSound::set_priority(int priority);

141 17 configure_filters 0 6 191 29 AudioSound::configure_filters 0 1 47 0
69
virtual bool AudioSound::configure_filters(FilterProperties *config);

142 6 status 0 6 191 18 AudioSound::status 0 1 48 0
67
virtual AudioSound::SoundStatus AudioSound::status(void) const = 0;

143 6 output 0 6 191 18 AudioSound::output 0 1 49 0
52
virtual void AudioSound::output(ostream &out) const;

144 5 write 0 6 191 17 AudioSound::write 0 1 50 0
51
virtual void AudioSound::write(ostream &out) const;

145 14 get_class_type 0 4 191 26 AudioSound::get_class_type 0 1 51 0
51
static TypeHandle AudioSound::get_class_type(void);

146 17 get_speaker_setup 0 6 193 31 AudioManager::get_speaker_setup 0 1 52 0
50
virtual int AudioManager::get_speaker_setup(void);

147 17 set_speaker_setup 0 6 193 31 AudioManager::set_speaker_setup 0 1 53 0
84
virtual void AudioManager::set_speaker_setup(AudioManager::SpeakerModeCategory cat);

148 17 configure_filters 0 6 193 31 AudioManager::configure_filters 0 1 54 0
71
virtual bool AudioManager::configure_filters(FilterProperties *config);

149 19 create_AudioManager 0 4 193 33 AudioManager::create_AudioManager 0 1 55 0
73
static PointerTo< AudioManager > AudioManager::create_AudioManager(void);

150 8 shutdown 0 6 193 22 AudioManager::shutdown 0 1 56 0
42
virtual void AudioManager::shutdown(void);

151 8 is_valid 0 6 193 22 AudioManager::is_valid 0 1 57 408
// If you're interested in knowing whether this audio manager is valid,
// here's the call to do it.  It is not necessary to check whether the audio
// manager is valid before making other calls.  You are free to use an
// invalid sound manager, you may get silent sounds from it though.  The
// sound manager and the sounds it creates should not crash the application
// even when the objects are not valid.
46
virtual bool AudioManager::is_valid(void) = 0;

152 9 get_sound 0 6 193 23 AudioManager::get_sound 0 2 58 59 15
// Get a sound:
303
virtual PointerTo< AudioSound > AudioManager::get_sound(std::string const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0;
virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0;

153 14 get_null_sound 0 4 193 28 AudioManager::get_null_sound 0 1 60 0
59
PointerTo< AudioSound > AudioManager::get_null_sound(void);

154 13 uncache_sound 0 6 193 27 AudioManager::uncache_sound 0 1 61 278
// Tell the AudioManager there is no need to keep this one cached.  This
// doesn't break any connection between AudioSounds that have already given
// by get_sound() from this manager.  It's only affecting whether the
// AudioManager keeps a copy of the sound in its poolcache.
75
virtual void AudioManager::uncache_sound(std::string const &file_name) = 0;

155 11 clear_cache 0 6 193 25 AudioManager::clear_cache 0 1 62 0
49
virtual void AudioManager::clear_cache(void) = 0;

156 15 set_cache_limit 0 6 193 29 AudioManager::set_cache_limit 0 1 63 0
67
virtual void AudioManager::set_cache_limit(unsigned int count) = 0;

157 15 get_cache_limit 0 6 193 29 AudioManager::get_cache_limit 0 1 64 0
67
virtual unsigned int AudioManager::get_cache_limit(void) const = 0;

158 10 set_volume 0 6 193 24 AudioManager::set_volume 0 1 65 194
// Control volume: FYI: If you start a sound with the volume off and turn
// the volume up later, you'll hear the sound playing at that late point.  0
// = minimum; 1.0 = maximum.  inits to 1.0.
62
virtual void AudioManager::set_volume(PN_stdfloat volume) = 0;

159 10 get_volume 0 6 193 24 AudioManager::get_volume 0 1 66 0
61
virtual PN_stdfloat AudioManager::get_volume(void) const = 0;

160 10 set_active 0 6 193 24 AudioManager::set_active 0 1 67 364
/*
 * Turn the manager on or off.  If you play a sound while the manager is
 * inactive, it won't start.  If you deactivate the manager while sounds are
 * playing, they'll stop.  If you activate the manager while looping sounds
 * are playing (those that have a loop_count of zero), they will start playing
 * from the beginning of their loop.  inits to true.
 */
53
virtual void AudioManager::set_active(bool flag) = 0;

161 10 get_active 0 6 193 24 AudioManager::get_active 0 1 68 0
54
virtual bool AudioManager::get_active(void) const = 0;

162 26 set_concurrent_sound_limit 0 6 193 40 AudioManager::set_concurrent_sound_limit 0 1 69 343
// This controls the number of sounds that you allow at once.  This is more
// of a user choice -- it avoids talk over and the creation of a cacophony.
// It can also be used to help performance.  0 == unlimited.  1 == mutually
// exclusive (one sound at a time).  Which is an example of: n == allow n
// sounds to be playing at the same time.
82
virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0;

163 26 get_concurrent_sound_limit 0 6 193 40 AudioManager::get_concurrent_sound_limit 0 1 70 0
78
virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0;

164 24 reduce_sounds_playing_to 0 6 193 38 AudioManager::reduce_sounds_playing_to 0 1 71 369
// This is likely to be a utility function for the concurrent_sound_limit
// options.  It is exposed as an API, because it's reasonable that it may be
// useful to be here.  It reduces the number of concurrently playing sounds
// to count by some implementation specific means.  If the number of sounds
// currently playing is at or below count then there is no effect.
76
virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0;

165 15 stop_all_sounds 0 6 193 29 AudioManager::stop_all_sounds 0 1 72 183
// Stop playback on all sounds managed by this manager.  This is effectively
// the same as reduce_sounds_playing_to(0), but this call may be for
// efficient on some implementations.
53
virtual void AudioManager::stop_all_sounds(void) = 0;

166 6 update 0 6 193 20 AudioManager::update 0 1 73 76
// This should be called every frame.  Failure to call could cause problems.
40
virtual void AudioManager::update(void);

167 32 audio_3d_set_listener_attributes 0 6 193 46 AudioManager::audio_3d_set_listener_attributes 0 1 74 326
// This controls the "set of ears" that listens to 3D spacialized sound px,
// py, pz are position coordinates.  vx, vy, vz are a velocity vector in
// UNITS PER SECOND (default: meters). fx, fy and fz are the respective
// components of a unit forward-vector ux, uy and uz are the respective
// components of a unit up-vector
252
virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz);

168 32 audio_3d_get_listener_attributes 0 6 193 46 AudioManager::audio_3d_get_listener_attributes 0 0 0
264
virtual void AudioManager::audio_3d_get_listener_attributes(PN_stdfloat *px, PN_stdfloat *py, PN_stdfloat *pz, PN_stdfloat *vx, PN_stdfloat *vy, PN_stdfloat *vz, PN_stdfloat *fx, PN_stdfloat *fy, PN_stdfloat *fz, PN_stdfloat *ux, PN_stdfloat *uy, PN_stdfloat *uz);

169 28 audio_3d_set_distance_factor 0 6 193 42 AudioManager::audio_3d_set_distance_factor 0 1 75 305
// Control the "relative scale that sets the distance factor" units for 3D
// spacialized audio. This is a float in units-per-meter. Default value is
// 1.0, which means that Panda units are understood as meters; for e.g.
// feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
// moment.
76
virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor);

170 28 audio_3d_get_distance_factor 0 6 193 42 AudioManager::audio_3d_get_distance_factor 0 1 76 0
75
virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const;

171 27 audio_3d_set_doppler_factor 0 6 193 41 AudioManager::audio_3d_set_doppler_factor 0 1 77 123
// Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
// Doppler, use >1.0 Diminshed Doppler, use <1.0
75
virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor);

172 27 audio_3d_get_doppler_factor 0 6 193 41 AudioManager::audio_3d_get_doppler_factor 0 1 78 0
74
virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const;

173 28 audio_3d_set_drop_off_factor 0 6 193 42 AudioManager::audio_3d_set_drop_off_factor 0 1 79 155
// Exaggerate or diminish the effect of distance on sound.  Default is 1.0
// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
// <1.0
76
virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor);

174 28 audio_3d_get_drop_off_factor 0 6 193 42 AudioManager::audio_3d_get_drop_off_factor 0 1 80 0
75
virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const;

175 16 get_dls_pathname 0 4 193 30 AudioManager::get_dls_pathname 0 1 81 0
53
static Filename AudioManager::get_dls_pathname(void);

176 6 output 0 6 193 20 AudioManager::output 0 1 82 0
54
virtual void AudioManager::output(ostream &out) const;

177 5 write 0 6 193 19 AudioManager::write 0 1 83 0
53
virtual void AudioManager::write(ostream &out) const;

178 25 set_speaker_configuration 0 6 193 39 AudioManager::set_speaker_configuration 0 1 84 52
// set_speaker_configuration is a Miles only method.
298
virtual void AudioManager::set_speaker_configuration(LVecBase3 *speaker1, LVecBase3 *speaker2 = NULL, LVecBase3 *speaker3 = NULL, LVecBase3 *speaker4 = NULL, LVecBase3 *speaker5 = NULL, LVecBase3 *speaker6 = NULL, LVecBase3 *speaker7 = NULL, LVecBase3 *speaker8 = NULL, LVecBase3 *speaker9 = NULL);

179 14 get_class_type 0 4 193 28 AudioManager::get_class_type 0 1 85 0
53
static TypeHandle AudioManager::get_class_type(void);

180 16 AudioLoadRequest 0 4 198 34 AudioLoadRequest::AudioLoadRequest 0 2 86 87 118
/**
 * Create a new AudioLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */
196
inline AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional);
inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default;

181 17 get_audio_manager 0 4 198 35 AudioLoadRequest::get_audio_manager 0 1 88 90
/**
 * Returns the AudioManager that will serve this asynchronous
 * AudioLoadRequest.
 */
69
inline AudioManager *AudioLoadRequest::get_audio_manager(void) const;

182 12 get_filename 0 4 198 30 AudioLoadRequest::get_filename 0 1 89 83
/**
 * Returns the filename associated with this asynchronous AudioLoadRequest.
 */
69
inline std::string const &AudioLoadRequest::get_filename(void) const;

183 14 get_positional 0 4 198 32 AudioLoadRequest::get_positional 0 1 90 93
/**
 * Returns the positional flag associated with this asynchronous
 * AudioLoadRequest.
 */
57
inline bool AudioLoadRequest::get_positional(void) const;

184 8 is_ready 0 4 198 26 AudioLoadRequest::is_ready 0 1 91 172
/**
 * Returns true if this request has completed, false if it is still pending.
 * When this returns true, you may retrieve the sound loaded by calling
 * get_sound().
 */
51
inline bool AudioLoadRequest::is_ready(void) const;

185 9 get_sound 0 4 198 27 AudioLoadRequest::get_sound 0 1 92 206
/**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless is_ready() returns
 * true.
 * @deprecated Use result() instead.
 */
59
inline AudioSound *AudioLoadRequest::get_sound(void) const;

186 6 result 0 4 198 24 AudioLoadRequest::result 0 1 93 169
/**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless is_ready() returns
 * true.
 */
56
inline AudioSound *AudioLoadRequest::result(void) const;

187 14 get_class_type 0 4 198 32 AudioLoadRequest::get_class_type 0 1 94 0
57
static TypeHandle AudioLoadRequest::get_class_type(void);

188 17 ~AudioLoadRequest 0 4 198 35 AudioLoadRequest::~AudioLoadRequest 0 0 0
42
AudioLoadRequest::~AudioLoadRequest(void);

94
1 0 0 7 3 200 0 0 0 0 
2 0 0 7 3 200 0 0 0 1 6 param0 0 201  
3 0 0 4 4 203 0 0 42 /**
 * Removes all DSP postprocessing.
 */ 1 4 this 3 200  
4 0 0 4 5 203 0 0 60 /**
 * Add a lowpass filter to the end of the DSP chain.
 */ 3 4 this 3 200  11 cutoff_freq 1 204  11 resonance_q 1 204  
5 0 0 4 6 203 0 0 61 /**
 * Add a highpass filter to the end of the DSP chain.
 */ 3 4 this 3 200  11 cutoff_freq 1 204  11 resonance_q 1 204  
6 0 0 4 7 203 0 0 57 /**
 * Add a echo filter to the end of the DSP chain.
 */ 5 4 this 3 200  6 drymix 1 204  6 wetmix 1 204  5 delay 1 204  10 decayratio 1 204  
7 0 0 4 8 203 0 0 59 /**
 * Add a flange filter to the end of the DSP chain.
 */ 5 4 this 3 200  6 drymix 1 204  6 wetmix 1 204  5 depth 1 204  4 rate 1 204  
8 0 0 4 9 203 0 0 60 /**
 * Add a distort filter to the end of the DSP chain.
 */ 2 4 this 3 200  5 level 1 204  
9 0 0 4 10 203 0 0 62 /**
 * Add a normalize filter to the end of the DSP chain.
 */ 4 4 this 3 200  8 fadetime 1 204  9 threshold 1 204  6 maxamp 1 204  
10 0 0 4 11 203 0 0 60 /**
 * Add a parameq filter to the end of the DSP chain.
 */ 4 4 this 3 200  11 center_freq 1 204  9 bandwidth 1 204  4 gain 1 204  
11 0 0 4 12 203 0 0 63 /**
 * Add a pitchshift filter to the end of the DSP chain.
 */ 4 4 this 3 200  5 pitch 1 204  7 fftsize 1 204  7 overlap 1 204  
12 0 0 4 13 203 0 0 59 /**
 * Add a chorus filter to the end of the DSP chain.
 */ 8 4 this 3 200  6 drymix 1 204  4 wet1 1 204  4 wet2 1 204  4 wet3 1 204  5 delay 1 204  4 rate 1 204  5 depth 1 204  
13 0 0 4 14 203 0 0 59 /**
 * Add a reverb filter to the end of the DSP chain.
 */ 15 4 this 3 200  8 drylevel 1 204  4 room 1 204  6 roomhf 1 204  9 decaytime 1 204  12 decayhfratio 1 204  16 reflectionslevel 1 204  16 reflectionsdelay 1 204  11 reverblevel 1 204  11 reverbdelay 1 204  9 diffusion 1 204  7 density 1 204  11 hfreference 1 204  6 roomlf 1 204  11 lfreference 1 204  
14 0 0 4 15 203 0 0 61 /**
 * Add a compress filter to the end of the DSP chain.
 */ 5 4 this 3 200  9 threshold 1 204  6 attack 1 204  7 release 1 204  10 gainmakeup 1 204  
15 0 0 7 16 207 0 0 0 0 
16 0 0 4 18 203 0 0 350 // For best compatibility, set the loop_count, volume, and balance, prior to
// calling play().  You may set them while they're playing, but it's
// implementation specific whether you get the results.  - Calling play() a
// second time on the same sound before it is finished will start the sound
// again (creating a skipping or stuttering effect). 1 4 this 3 208  
17 0 0 4 19 203 0 0 0 1 4 this 3 208  
18 0 0 4 20 203 0 0 65 // loop: false = play once; true = play forever.  inits to false. 2 4 this 3 208  4 loop 1 209  
19 0 0 6 21 209 0 0 0 1 4 this 3 210  
20 0 0 4 22 203 0 0 73 // loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1. 2 4 this 3 208  10 loop_count 1 212  
21 0 0 6 23 212 0 0 0 1 4 this 3 210  
22 0 0 4 24 203 0 0 669 /*
 * Control time position within the sound.  This is similar (in concept) to
 * the seek position within a file.  time in seconds: 0 = beginning; length()
 * = end.  inits to 0.0. - The current time position will not change while the
 * sound is playing; you must call play() again to effect the change.  To play
 * the same sound from a time offset a second time, explicitly set the time
 * position again.  When looping, the second and later loops will start from
 * the beginning of the sound.  - If a sound is playing, calling get_time()
 * repeatedly will return different results over time.  e.g.: PN_stdfloat
 * percent_complete = s.get_time()  s.length();
 */ 2 4 this 3 208  10 start_time 1 204  
23 0 0 6 25 204 0 0 0 1 4 this 3 210  
24 0 0 4 26 203 0 0 45 // 0 = minimum; 1.0 = maximum.  inits to 1.0. 2 4 this 3 208  6 volume 1 204  
25 0 0 6 27 204 0 0 0 1 4 this 3 210  
26 0 0 4 28 203 0 0 68 // -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0. 2 4 this 3 208  13 balance_right 1 204  
27 0 0 6 29 204 0 0 0 1 4 this 3 210  
28 0 0 4 30 203 0 0 62 // play_rate is any positive PN_stdfloat value.  inits to 1.0. 2 4 this 3 208  9 play_rate 1 204  
29 0 0 6 31 204 0 0 0 1 4 this 3 210  
30 0 0 4 32 203 0 0 28 // inits to manager's state. 2 4 this 3 208  4 flag 1 209  
31 0 0 6 33 209 0 0 0 1 4 this 3 210  
32 0 0 4 34 203 0 0 126 // Set (or clear) the event that will be thrown when the sound finishes
// playing.  To clear the event, pass an empty string. 2 4 this 3 208  5 event 1 213  
33 0 0 6 35 213 0 0 0 1 4 this 3 210  
34 0 0 6 36 213 0 0 47 // There is no set_name(), this is intentional. 1 4 this 3 210  
35 0 0 6 37 204 0 0 35 // return: playing time in seconds. 1 4 this 3 210  
36 0 0 4 38 203 0 0 179 // Controls the position of this sound's emitter.  px, py and pz are the
// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
// PER SECOND (default: meters). 7 4 this 3 208  2 px 1 204  2 py 1 204  2 pz 1 204  2 vx 1 204  2 vy 1 204  2 vz 1 204  
37 0 0 4 40 203 0 0 168 // Controls the distance (in units) that this sound begins to fall off.
// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
// FartherSlower, >1.0 2 4 this 3 208  4 dist 1 204  
38 0 0 6 41 204 0 0 0 1 4 this 3 210  
39 0 0 4 42 203 0 0 222 // Controls the maximum distance (in units) that this sound stops falling
// off.  The sound does not stop at that point, it just doesn't get any
// quieter.  You should rarely need to adjust this.  Default is 1000000000.0 2 4 this 3 208  4 dist 1 204  
40 0 0 6 43 204 0 0 0 1 4 this 3 210  
41 0 0 6 44 204 0 0 312 // *_speaker_mix and *_speaker_level(s) serve the same purpose.
// *_speaker_mix is for use with FMOD. *_speaker_level(s) is for use with
// Miles.  Both interfaces exist because of a significant difference in the
// two APIs.  Hopefully the difference can be reconciled into a single
// interface at some point. 2 4 this 3 208  7 speaker 1 214  
42 0 0 4 45 203 0 0 0 9 4 this 3 208  9 frontleft 1 204  10 frontright 1 204  6 center 1 204  3 sub 1 204  8 backleft 1 204  9 backright 1 204  8 sideleft 1 204  9 sideright 1 204  
43 0 0 6 46 204 0 0 0 2 4 this 3 208  5 index 1 214  
44 0 0 4 47 203 0 0 0 10 4 this 3 208  6 level1 1 204  6 level2 1 204  6 level3 1 204  6 level4 1 204  6 level5 1 204  6 level6 1 204  6 level7 1 204  6 level8 1 204  6 level9 1 204  
45 0 0 6 48 214 0 0 0 1 4 this 3 208  
46 0 0 4 49 203 0 0 0 2 4 this 3 208  8 priority 1 214  
47 0 0 6 50 209 0 0 0 2 4 this 3 208  6 config 1 200  
48 0 0 6 52 192 0 0 0 1 4 this 3 210  
49 0 0 4 53 203 0 0 0 2 4 this 3 210  3 out 1 215  
50 0 0 4 54 203 0 0 0 2 4 this 3 210  3 out 1 215  
51 0 0 7 55 207 0 0 0 0 
52 0 0 6 60 214 0 0 0 1 4 this 3 217  
53 0 0 4 61 203 0 0 0 2 4 this 3 217  3 cat 1 194  
54 0 0 6 62 209 0 0 0 2 4 this 3 217  6 config 1 200  
55 0 0 7 63 217 0 0 0 0 
56 0 0 4 64 203 0 0 0 1 4 this 3 217  
57 0 0 6 65 209 0 0 408 // If you're interested in knowing whether this audio manager is valid,
// here's the call to do it.  It is not necessary to check whether the audio
// manager is valid before making other calls.  You are free to use an
// invalid sound manager, you may get silent sounds from it though.  The
// sound manager and the sounds it creates should not crash the application
// even when the objects are not valid. 1 4 this 3 217  
58 0 0 7 66 208 0 0 0 4 4 this 3 217  6 source 1 218  10 positional 1 209  4 mode 1 214  
59 0 0 7 66 208 0 0 15 // Get a sound: 4 4 this 3 217  9 file_name 1 213  10 positional 1 209  4 mode 1 214  
60 0 0 7 67 208 0 0 0 1 4 this 3 217  
61 0 0 4 68 203 0 0 278 // Tell the AudioManager there is no need to keep this one cached.  This
// doesn't break any connection between AudioSounds that have already given
// by get_sound() from this manager.  It's only affecting whether the
// AudioManager keeps a copy of the sound in its poolcache. 2 4 this 3 217  9 file_name 1 213  
62 0 0 4 69 203 0 0 0 1 4 this 3 217  
63 0 0 4 70 203 0 0 0 2 4 this 3 217  5 count 1 220  
64 0 0 6 71 220 0 0 0 1 4 this 3 221  
65 0 0 4 72 203 0 0 194 // Control volume: FYI: If you start a sound with the volume off and turn
// the volume up later, you'll hear the sound playing at that late point.  0
// = minimum; 1.0 = maximum.  inits to 1.0. 2 4 this 3 217  6 volume 1 204  
66 0 0 6 73 204 0 0 0 1 4 this 3 221  
67 0 0 4 74 203 0 0 364 /*
 * Turn the manager on or off.  If you play a sound while the manager is
 * inactive, it won't start.  If you deactivate the manager while sounds are
 * playing, they'll stop.  If you activate the manager while looping sounds
 * are playing (those that have a loop_count of zero), they will start playing
 * from the beginning of their loop.  inits to true.
 */ 2 4 this 3 217  4 flag 1 209  
68 0 0 6 75 209 0 0 0 1 4 this 3 221  
69 0 0 4 76 203 0 0 343 // This controls the number of sounds that you allow at once.  This is more
// of a user choice -- it avoids talk over and the creation of a cacophony.
// It can also be used to help performance.  0 == unlimited.  1 == mutually
// exclusive (one sound at a time).  Which is an example of: n == allow n
// sounds to be playing at the same time. 2 4 this 3 217  5 limit 1 220  
70 0 0 6 77 220 0 0 0 1 4 this 3 221  
71 0 0 4 78 203 0 0 369 // This is likely to be a utility function for the concurrent_sound_limit
// options.  It is exposed as an API, because it's reasonable that it may be
// useful to be here.  It reduces the number of concurrently playing sounds
// to count by some implementation specific means.  If the number of sounds
// currently playing is at or below count then there is no effect. 2 4 this 3 217  5 count 1 220  
72 0 0 4 79 203 0 0 183 // Stop playback on all sounds managed by this manager.  This is effectively
// the same as reduce_sounds_playing_to(0), but this call may be for
// efficient on some implementations. 1 4 this 3 217  
73 0 0 4 80 203 0 0 76 // This should be called every frame.  Failure to call could cause problems. 1 4 this 3 217  
74 0 0 4 81 203 0 0 326 // This controls the "set of ears" that listens to 3D spacialized sound px,
// py, pz are position coordinates.  vx, vy, vz are a velocity vector in
// UNITS PER SECOND (default: meters). fx, fy and fz are the respective
// components of a unit forward-vector ux, uy and uz are the respective
// components of a unit up-vector 13 4 this 3 217  2 px 1 204  2 py 1 204  2 pz 1 204  2 vx 1 204  2 vy 1 204  2 vz 1 204  2 fx 1 204  2 fy 1 204  2 fz 1 204  2 ux 1 204  2 uy 1 204  2 uz 1 204  
75 0 0 4 83 203 0 0 305 // Control the "relative scale that sets the distance factor" units for 3D
// spacialized audio. This is a float in units-per-meter. Default value is
// 1.0, which means that Panda units are understood as meters; for e.g.
// feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
// moment. 2 4 this 3 217  6 factor 1 204  
76 0 0 6 84 204 0 0 0 1 4 this 3 221  
77 0 0 4 85 203 0 0 123 // Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
// Doppler, use >1.0 Diminshed Doppler, use <1.0 2 4 this 3 217  6 factor 1 204  
78 0 0 6 86 204 0 0 0 1 4 this 3 221  
79 0 0 4 87 203 0 0 155 // Exaggerate or diminish the effect of distance on sound.  Default is 1.0
// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
// <1.0 2 4 this 3 217  6 factor 1 204  
80 0 0 6 88 204 0 0 0 1 4 this 3 221  
81 0 0 7 89 223 0 0 0 0 
82 0 0 4 92 203 0 0 0 2 4 this 3 221  3 out 1 215  
83 0 0 4 93 203 0 0 0 2 4 this 3 221  3 out 1 215  
84 0 0 4 94 203 0 0 52 // set_speaker_configuration is a Miles only method. 10 4 this 3 217  8 speaker1 1 224  8 speaker2 1 224  8 speaker3 1 224  8 speaker4 1 224  8 speaker5 1 224  8 speaker6 1 224  8 speaker7 1 224  8 speaker8 1 224  8 speaker9 1 224  
85 0 0 7 95 207 0 0 0 0 
86 0 0 7 98 229 188 0 0 1 6 param0 0 227  
87 0 0 7 98 229 188 0 118 /**
 * Create a new AudioLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */ 3 13 audio_manager 1 217  8 filename 1 213  10 positional 1 209  
88 0 0 7 99 217 0 0 90 /**
 * Returns the AudioManager that will serve this asynchronous
 * AudioLoadRequest.
 */ 1 4 this 3 227  
89 0 0 6 100 213 0 0 83 /**
 * Returns the filename associated with this asynchronous AudioLoadRequest.
 */ 1 4 this 3 227  
90 0 0 6 101 209 0 0 93 /**
 * Returns the positional flag associated with this asynchronous
 * AudioLoadRequest.
 */ 1 4 this 3 227  
91 0 0 6 102 209 0 0 172 /**
 * Returns true if this request has completed, false if it is still pending.
 * When this returns true, you may retrieve the sound loaded by calling
 * get_sound().
 */ 1 4 this 3 227  
92 0 0 7 103 208 0 0 206 /**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless is_ready() returns
 * true.
 * @deprecated Use result() instead.
 */ 1 4 this 3 227  
93 0 0 7 104 208 0 0 169 /**
 * Returns the sound that was loaded asynchronously, if any, or nullptr if
 * there was an error.  It is an error to call this unless is_ready() returns
 * true.
 */ 1 4 this 3 227  
94 0 0 7 105 207 0 0 0 0 
41
189 16 FilterProperties 0 75777 16 FilterProperties 16 FilterProperties 0 0 0 1 95 0 0 13 96 97 98 99 100 101 102 103 104 105 106 107 108 0 0 1 0 190 0 0 0 0 0

190 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

191 10 AudioSound 0 75777 10 AudioSound 10 AudioSound 0 0 0 0 0 0 37 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 0 0 1 0 190 0 0 0 1 192 0

192 11 SoundStatus 0 794624 23 AudioSound::SoundStatus 23 AudioSound::SoundStatus 191 0 0 0 0 0 0 0 0 0 3 3 BAD 15 AudioSound::BAD 0
0 5 READY 17 AudioSound::READY 0
1 7 PLAYING 19 AudioSound::PLAYING 0
2 0 0

193 12 AudioManager 0 75777 12 AudioManager 12 AudioManager 0 0 0 0 0 1 230 34 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 0 0 1 0 190 0 0 0 3 194 195 196 0

194 19 SpeakerModeCategory 0 794624 33 AudioManager::SpeakerModeCategory 33 AudioManager::SpeakerModeCategory 193 0 0 0 0 0 0 0 0 0 9 15 SPEAKERMODE_raw 29 AudioManager::SPEAKERMODE_raw 79
// These enumerants line up one-to-one with the FMOD SPEAKERMODE
// enumerants.
0 16 SPEAKERMODE_mono 30 AudioManager::SPEAKERMODE_mono 0
1 18 SPEAKERMODE_stereo 32 AudioManager::SPEAKERMODE_stereo 0
2 16 SPEAKERMODE_quad 30 AudioManager::SPEAKERMODE_quad 0
3 20 SPEAKERMODE_surround 34 AudioManager::SPEAKERMODE_surround 0
4 19 SPEAKERMODE_5point1 33 AudioManager::SPEAKERMODE_5point1 0
5 19 SPEAKERMODE_7point1 33 AudioManager::SPEAKERMODE_7point1 0
6 15 SPEAKERMODE_max 29 AudioManager::SPEAKERMODE_max 0
7 17 SPEAKERMODE_COUNT 31 AudioManager::SPEAKERMODE_COUNT 0
8 0 0

195 9 SpeakerId 0 794624 23 AudioManager::SpeakerId 23 AudioManager::SpeakerId 193 0 0 0 0 0 0 0 0 0 10 8 SPK_none 22 AudioManager::SPK_none 0
0 13 SPK_frontleft 27 AudioManager::SPK_frontleft 0
1 14 SPK_frontright 28 AudioManager::SPK_frontright 0
2 10 SPK_center 24 AudioManager::SPK_center 0
3 7 SPK_sub 21 AudioManager::SPK_sub 0
4 12 SPK_backleft 26 AudioManager::SPK_backleft 0
5 13 SPK_backright 27 AudioManager::SPK_backright 0
6 12 SPK_sideleft 26 AudioManager::SPK_sideleft 0
7 13 SPK_sideright 27 AudioManager::SPK_sideright 0
8 9 SPK_COUNT 23 AudioManager::SPK_COUNT 0
9 0 0

196 10 StreamMode 0 794624 24 AudioManager::StreamMode 24 AudioManager::StreamMode 193 0 0 0 0 0 0 0 0 0 3 12 SM_heuristic 26 AudioManager::SM_heuristic 0
0 9 SM_sample 23 AudioManager::SM_sample 0
1 9 SM_stream 23 AudioManager::SM_stream 0
2 0 0

197 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

198 16 AudioLoadRequest 0 141313 16 AudioLoadRequest 16 AudioLoadRequest 0 0 0 1 180 188 0 7 181 182 183 184 185 186 187 0 0 1 0 199 0 0 0 0 300
/**
 * A class object that manages a single asynchronous audio load request.  This
 * works in conjunction with the Loader class defined in pgraph, or really
 * with any AsyncTaskManager.  Create a new AudioLoadRequest, and add it to
 * the loader via load_async(), to begin an asynchronous load.
 */

199 9 AsyncTask 0 2049 9 AsyncTask 9 AsyncTask 0 0 0 0 0 0 0 0 0 0 0 0 217
/**
 * This class represents a concrete task performed by an AsyncManager.
 * Normally, you would subclass from this class, and override do_task(), to
 * define the functionality you wish to have the task perform.
 */

200 18 FilterProperties * 0 8576 18 FilterProperties * 18 FilterProperties * 0 0 189 0 0 0 0 0 0 0 0 0 0

201 24 FilterProperties const * 0 8576 24 FilterProperties const * 24 FilterProperties const * 0 0 202 0 0 0 0 0 0 0 0 0 0

202 22 FilterProperties const 0 8832 22 FilterProperties const 22 FilterProperties const 0 0 189 0 0 0 0 0 0 0 0 0 0

203 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

204 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 205 0 0 0 0 0 0 0 0 0 0

205 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

206 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

207 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 206 0 0 0 0 0 0 0 0 0 0

208 12 AudioSound * 0 8576 12 AudioSound * 12 AudioSound * 0 0 191 0 0 0 0 0 0 0 0 0 0

209 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

210 18 AudioSound const * 0 8576 18 AudioSound const * 18 AudioSound const * 0 0 211 0 0 0 0 0 0 0 0 0 0

211 16 AudioSound const 0 8832 16 AudioSound const 16 AudioSound const 0 0 191 0 0 0 0 0 0 0 0 0 0

212 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

213 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

214 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

215 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 216 0 0 0 0 0 0 0 0 0 0

216 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

217 14 AudioManager * 0 8576 14 AudioManager * 14 AudioManager * 0 0 193 0 0 0 0 0 0 0 0 0 0

218 12 MovieAudio * 0 8576 12 MovieAudio * 12 MovieAudio * 0 0 219 0 0 0 0 0 0 0 0 0 0

219 10 MovieAudio 0 2048 10 MovieAudio 10 MovieAudio 0 0 0 0 0 0 0 0 0 0 0 0 397
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.
 *
 * The difference between a MovieAudio and a MovieAudioCursor is like the
 * difference between a filename and a file handle.  The MovieAudio just
 * indicates a particular movie.  The MovieAudioCursor is what allows access.
 */

220 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

221 20 AudioManager const * 0 8576 20 AudioManager const * 20 AudioManager const * 0 0 222 0 0 0 0 0 0 0 0 0 0

222 18 AudioManager const 0 8832 18 AudioManager const 18 AudioManager const 0 0 193 0 0 0 0 0 0 0 0 0 0

223 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 197 0 0 0 0 0 0 0 0 0 0

224 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 225 0 0 0 0 0 0 0 0 0 0

225 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 226 0 0 0 0 0 0 0 0 0 0

226 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

227 24 AudioLoadRequest const * 0 8576 24 AudioLoadRequest const * 24 AudioLoadRequest const * 0 0 228 0 0 0 0 0 0 0 0 0 0

228 22 AudioLoadRequest const 0 8832 22 AudioLoadRequest const 22 AudioLoadRequest const 0 0 198 0 0 0 0 0 0 0 0 0 0

229 18 AudioLoadRequest * 0 8576 18 AudioLoadRequest * 18 AudioLoadRequest * 0 0 198 0 0 0 0 0 0 0 0 0 0

0
1
230 12 dls_pathname 0 2 0 175 0 0 0 0 0 26 AudioManager::dls_pathname 0

0
